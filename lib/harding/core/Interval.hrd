# ============================================================================
# Interval - A finite arithmetic progression
# Similar to Smalltalk's Interval, supports (1 to: 10) and (1 to: 10 by: 2)
# ============================================================================

Interval := Object derive: #(start stop step)

Interval>>initialize [
  # Initialize default step
  step := 1
]

Interval>>start: aNumber [
  start := aNumber
]

Interval>>stop: aNumber [
  stop := aNumber
]

Interval>>step: aNumber [
  step := aNumber
]

Interval>>start [
  ^ start
]

Interval>>stop [
  ^ stop
]

Interval>>step [
  ^ step
]

Interval>>size [
  # Calculate the number of elements in the interval
  | count current |
  count := 0.
  current := start.

  step > 0 ifTrue: [
    [ current <= stop ] whileTrue: [
      count := count + 1.
      current := current + step
    ]
  ] ifFalse: [
    [ current >= stop ] whileTrue: [
      count := count + 1.
      current := current + step
    ]
  ].

  ^ count
]

Interval>>isEmpty [
  ^ self size = 0
]

Interval>>includes: aNumber [
  # Check if a number is in the interval
  | diff |

  # Check bounds
  step > 0 ifTrue: [
    (aNumber < start or: [ aNumber > stop ]) ifTrue: [ ^ false ]
  ] ifFalse: [
    (aNumber > start or: [ aNumber < stop ]) ifTrue: [ ^ false ]
  ].

  # Check if it's on the step
  diff := aNumber - start.
  ^ (diff \\ step) = 0
]

Interval>>at: index [
  # Get element at 1-based index
  ^ start + ((index - 1) * step)
]

Interval>>do: block [
  # Iterate over each element in the interval
  | current |
  current := start.

  step > 0 ifTrue: [
    [ current <= stop ] whileTrue: [
      block value: current.
      current := current + step
    ]
  ] ifFalse: [
    [ current >= stop ] whileTrue: [
      block value: current.
      current := current + step
    ]
  ].

  ^ self
]

Interval>>doWithIndex: block [
  # Iterate with 1-based index
  | current index |
  current := start.
  index := 1.

  step > 0 ifTrue: [
    [ current <= stop ] whileTrue: [
      block value: current value: index.
      current := current + step.
      index := index + 1
    ]
  ] ifFalse: [
    [ current >= stop ] whileTrue: [
      block value: current value: index.
      current := current + step.
      index := index + 1
    ]
  ].

  ^ self
]

Interval>>collect: block [
  # Transform each element, return Array with results
  | result |
  result := Array new.
  self do: [ :each | result add: (block value: each) ].
  ^ result
]

Interval>>select: block [
  # Return Array with elements where block returns true
  | result |
  result := Array new.
  self do: [ :each |
    (block value: each) ifTrue: [ result add: each ]
  ].
  ^ result
]

Interval>>reject: block [
  # Return Array with elements where block returns false
  | result |
  result := Array new.
  self do: [ :each |
    (block value: each) ifFalse: [ result add: each ]
  ].
  ^ result
]

Interval>>detect: block [
  # Find first element satisfying block
  self do: [ :each |
    (block value: each) ifTrue: [ ^ each ]
  ].
  ^ nil
]

Interval>>detect: block ifNone: noneBlock [
  # Find first element or evaluate noneBlock
  self do: [ :each |
    (block value: each) ifTrue: [ ^ each ]
  ].
  ^ noneBlock value
]

Interval>>inject: initialValue into: block [
  # Accumulate result
  | result |
  result := initialValue.
  self do: [ :each | result := block value: result value: each ].
  ^ result
]

Interval>>anySatisfy: block [
  # Return true if any element satisfies block
  self do: [ :each |
    (block value: each) ifTrue: [ ^ true ]
  ].
  ^ false
]

Interval>>allSatisfy: block [
  # Return true if all elements satisfy block
  self do: [ :each |
    (block value: each) ifFalse: [ ^ false ]
  ].
  ^ true
]

Interval>>sum [
  # Return sum of all elements
  ^ self inject: 0 into: [ :sum :each | sum + each ]
]

Interval>>max [
  # Return maximum value
  step > 0 ifTrue: [ ^ stop ] ifFalse: [ ^ start ]
]

Interval>>min [
  # Return minimum value
  step > 0 ifTrue: [ ^ start ] ifFalse: [ ^ stop ]
]

Interval>>asArray [
  # Convert to Array
  ^ self collect: [ :each | each ]
]

Interval>>asOrderedCollection [
  # For compatibility - in Harding, Array is the ordered collection
  ^ self asArray
]

Interval>>to: end [
  # Create new Interval from stop to end with same step
  ^ Interval from: start to: end by: step
]

Interval>>to: end by: increment [
  # Create new Interval from stop to end with different step
  ^ Interval from: start to: end by: increment
]

Interval>>printString [
  # String representation
  ^ "(" , (start printString) , " to: " , (stop printString) ,
    (step = 1 ifTrue: [""] ifFalse: [" by: " , (step printString)]) ,
    ")"
]

# ============================================================================
# Class methods
# ============================================================================

Interval class>>new [
  # Intervals should be created with from:to: or from:to:by:
  # Use basicNew here to avoid recursion, then initialize manually
  | instance |
  instance := self basicNew.
  instance initialize.
  instance start: 1.
  instance stop: 1.
  instance step: 1.
  ^ instance
]

Interval class>>from: start to: stop [
  ^ self from: start to: stop by: 1
]

Interval class>>from: start to: stop by: stepValue [
  | instance |
  instance := self new.
  instance start: start.
  instance stop: stop.
  instance step: stepValue.
  ^ instance
]
