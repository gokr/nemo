import std/[strutils, tables, sequtils, os, strformat]
import ../core/types
import ../parser/parser
import ../parser/lexer
import ../compiler/context
import ../compiler/analyzer
import ../compiler/inference
import ../compiler/symbols
import ./slots
import ./methods
import ./primitive
import ./control
import ./expression

# ============================================================================
# Module Generation
# Generates complete Nim modules from Nimtalk source
# ============================================================================

proc genModuleHeader*(ctx: var CompilerContext, moduleName: string): string =
  ## Generate module header with imports and documentation
  var result = ""

  result.add("## Generated by Nimtalk Compiler\n")
  result.add("## Module: " & moduleName & "\n")
  result.add("## Do not edit - generated from .nt source\n\n")

  result.add("# Imports\n")
  result.add("import std/[tables, sequtils]\n")
  result.add("import nimtalk/core/[types]\n")
  result.add("import nimtalk/interpreter/[objects, activation]\n\n")

  result.add("# Runtime imports (placeholder)\n")
  result.add("# import nimtalk/runtime/runtime\n\n")

  return result

proc genPrototypeConstants*(proto: PrototypeInfo): string =
  ## Generate prototype constant declarations
  let protoName = manglePrototype(proto.name)

  var result = fmt("# {proto.name} Prototype\n")
  result.add("###################\n\n")

  # Slot count constant
  let slots = proto.getAllSlots()
  result.add(fmt("const {protoName}_slotCount* = {slots.len}\n"))

  # Slot name array
  if slots.len > 0:
    let slotNames = slots.mapIt(fmt("\"{it.name}\"")).join(", ")
    result.add(fmt("\nconst {protoName}_slotNames*: array[{slots.len}, string] = [\n"))
    result.add("  " & slotNames & "\n")
    result.add("]\n")

  # Method count
  result.add(fmt("\nconst {protoName}_methodCount = {proto.methods.len}\n"))

  result.add("\n")

  return result

proc genPrototypeInit*(proto: PrototypeInfo): string =
  ## Generate prototype initialization procedure
  let protoName = manglePrototype(proto.name)

  var result = fmt("""
proc init_{protoName}*(parent: ref ProtoObject = nil): ref ProtoObject {{.cdecl, exportc.}} =
  ## Initialize {proto.name} prototype
  ##
  var obj = if parent != nil:
              parent.clone()
            else:
              rootObject.clone()

  obj.tags.add("{proto.name}")

  # Initialize slots
  obj.slots.setLen({proto.getAllSlots().len()})

  # Register methods
  for meth in obj.methods.values:
    meth.nativeImpl = nil  # No native implementation yet

  return obj

""")

  return result

proc genModule*(ctx: var CompilerContext, nodes: seq[Node],
                moduleName: string): string =
  ## Generate complete Nim module from parsed nodes
  var result = ""

  result.add(genModuleHeader(ctx, moduleName))
  result.add(genRuntimeHelperMethods())
  result.add("\n")

  # Analyze prototypes
  let analysis = buildPrototypeGraph(nodes)

  # Resolve slot indices
  ctx.resolveSlotIndices()

  # Generate for each prototype
  for proto in analysis.prototypes.values:
    result.add(genPrototypeConstants(proto))
    result.add(genSlotAccessors(proto))
    result.add(genPrototypeInit(proto))

  # Generate control flow methods
  result.add("\n")
  result.add("# Control Flow Methods\n")
  result.add("######################\n\n")

  result.add(genWhileTrueMethod())
  result.add(genWhileFalseMethod())
  result.add(genIfTrueIfFalseMethod())
  result.add(genTimesRepeatMethod())

  # Generate binary operators
  result.add("\n")
  result.add("# Binary Operators\n")
  result.add("#################\n\n")

  for op in ["+", "-", "*", "/"]:
    result.add(genBinaryOpMethod(op))

  # Generate comparison operators
  result.add("\n")
  result.add("# Comparison Operators\n")
  result.add("#####################\n\n")

  for op in ["<", "<=", ">", ">=", "="]:
    result.add(genComparisonMethod(op))

  # Generate primitive helpers
  result.add("\n")
  result.add(genPrimitiveRuntimeHelper())

  # Module initialization
  result.add("\n")
  result.add("# Module Initialization\n")
  result.add("######################\n")

  result.add(fmt("""
proc init_{moduleName}*() =
  ## Initialize {moduleName} module
  echo "Module loaded: {moduleName}"

when isMainModule:
  init_{moduleName}()
"""))

  return result

proc compileFile*(inputPath: string, outputDir = "./build"): string =
  ## Compile a Nimtalk source file to Nim
  let source = readFile(inputPath)
  let tokens = lex(source)
  var parser = initParser(tokens)
  let nodes = parser.parseStatements()

  if parser.hasError:
    echo "Parse error: " & parser.errorMsg
    return ""

  let moduleName = inputPath.extractFilename().changeFileExt("")

  var ctx = newCompiler(outputDir, moduleName)
  let nimCode = genModule(ctx, nodes, moduleName)

  let outputPath = outputDir / moduleName & ".nim"
  createDir(outputDir)
  writeFile(outputPath, nimCode)

  return outputPath
